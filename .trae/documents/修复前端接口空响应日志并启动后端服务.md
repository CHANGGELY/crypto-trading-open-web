## 根因分析
- 后端未运行或异常导致 `net::ERR_EMPTY_RESPONSE`：前端请求 `http://localhost:8000/api/trades` 与 `http://localhost:8000/api/nav` 返回空连接，浏览器报错。
- 前端对 `/api/nav` 错误处理不足：`渲染净值对比` 未像 `渲染交易标记` 那样完整进行 `r.ok` 检查与 `try/catch`，触发 `TypeError: Failed to fetch`。
- 代码定位：
  - 前端入口与脚本：`web/index.html:74` 引入 `app.js`；页面容器 `web/index.html:60,66`
  - 加载链路：`web/app.js:42-58`（加载结果）；价格渲染 `web/app.js:60-136`
  - 交易标记：`web/app.js:138-165`（已具备较完整错误处理）
  - 净值对比：`web/app.js:167-207`（需要补齐错误处理）
  - 后端接口：`server.py:149-181`（/api/trades），`server.py:182-207`（/api/nav）

## 修复方案
- 启动后端服务（必须）：
  - 使用命令启动 `server.py` 于 `8000` 端口，确保前端请求可用。
  - 命令：`python -X utf8 server.py`
  - 若端口占用或防火墙拦截，改用备用端口并同步更新前端基址（当前前端使用相对路径，保持 8000 更稳妥）。
- 前端增强 `/api/nav` 请求的健壮性：
  - 在 `web/app.js:167-207` 的 `渲染净值对比(names)` 中：
    - 对 `fetch('/api/nav?...')` 增加 `r.ok` 校验；
    - 将 `await r.json()` 包裹入 `try/catch` 并提供降级空结构；
    - 所有错误通过页面的调试输出（与 `渲染交易标记` 风格一致），避免未捕获异常；
    - 当数据为空或结构不符时，安全跳过绘制，不抛错。
- 可选的小重构（若你同意）：
  - 提取一个轻量的通用 `安全获取(url)` 方法，封装 `fetch + r.ok + json/catch`，同时复用于 `渲染交易标记` 与 `渲染净值对比`，减少重复代码。

## 具体改动点
- `web/app.js:167-207`：为 `渲染净值对比` 增加完整的错误处理与容错，输出人类可读的中文提示；数据结构校验后再 `setData`。
- 不改动 `index.html` 的脚本路径（`/app.js`），因 `server.py` 的静态映射已正确服务 `web` 目录。
- 后端不需改动逻辑；只需确保服务运行，数据文件存在（例如 `results_short_demo.json`）。

## 验证步骤
- 启动后端后，打开页面并执行默认加载：
  - 控制台应不再出现三条错误（两条 `ERR_EMPTY_RESPONSE` 与一条 `TypeError: Failed to fetch`）。
  - 价格图加载，交易标记叠加成功；净值图至少绘制一条曲线；时间轴自适应。
- 端到端检查（自动化）：
  - 访问首页，等待 `#price` 与 `#nav` 序列存在；
  - 读取控制台日志，确保无 `ERR_EMPTY_RESPONSE`、无 `Failed to fetch`；
  - 变更选择的结果文件与时间框，重复检查。

## 风险与注意
- 端口与权限：Windows 上防火墙或端口占用可能导致连接空响应，需要切换端口或授权。
- 数据文件一致性：`results_short_demo.json` 必须包含 `nav_series` 与 `trade_marks` 字段，否则前端应给出友好提示但不报错。
- 字符编码：统一使用 `UTF-8` 以避免中文路径或内容造成解析异常。

## 下一步
- 若你确认上述方案，我将：
  - 启动后端服务并修复前端 `渲染净值对比` 的错误处理；
  - 运行页面验证与自动化检查，确保三条错误完全消失；
  - 回传修改的精确行号与最终效果截图/预览链接。